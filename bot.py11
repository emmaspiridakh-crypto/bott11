import discord
from discord.ext import commands
import asyncio
from flask import Flask
from threading import Thread

# ==========================
# 24/7 REPLIT WEBSERVER
# ==========================

app = Flask('')

@app.route('/')
def home():
    return "Bot is alive!"

def run_webserver():
    app.run(host='0.0.0.0', port=8080)

def keep_alive():
    server = Thread(target=run_webserver)
    server.start()

# ==========================
# BOT SETUP
# ==========================

intents = discord.Intents.all()
bot = commands.Bot(command_prefix="!", intents=intents)

# ==========================
# CONFIG â€“ Î’Î‘Î›Î• Î¤Î‘ Î”Î™ÎšÎ‘ Î£ÎŸÎ¥ IDs
# ==========================

GUILD_ID = 1465344517090840639

LOGS_CHANNEL_ID = 1465370236243939379
AUTOROLE_ID = 1465357638593151331

SUPPORT_TICKET_CATEGORY_ID = 1465366628622667830
BUY_TICKET_CATEGORY_ID = 1465375930321997986
APPLICATION_CATEGORY_ID = 1465726366229205043

SUPPORT_CALL_VC_ID = 1465366816959234109
TEMP_SUPPORT_CATEGORY_ID = 1465366473030635788

OWNER_ROLE_ID = 1465345430392017091
CEO_ROLE_ID = 1465362545668788320
MANAGER_ROLE_ID = 1465360458537111582
STAFF_ROLE_ID = 1467220345126654185

# REVIEW CHANNELS Î“Î™Î‘ APPLICATIONS
STAFF_APPS_REVIEW_CHANNEL_ID = 1465727938988081310
MANAGER_APPS_REVIEW_CHANNEL_ID = 1465728075160621229

# ==========================
# HELPERS
# ==========================

def has_role(member: discord.Member, role_id: int) -> bool:
    role = member.guild.get_role(role_id)
    return role in member.roles if role else False

def is_owner_or_ceo(member: discord.Member) -> bool:
    return has_role(member, OWNER_ROLE_ID) or has_role(member, CEO_ROLE_ID)

def is_staff_or_higher(member: discord.Member) -> bool:
    return any([
        has_role(member, STAFF_ROLE_ID),
        has_role(member, MANAGER_ROLE_ID),
        has_role(member, CEO_ROLE_ID),
        has_role(member, OWNER_ROLE_ID),
    ])

def is_manager_or_higher(member: discord.Member) -> bool:
    return any([
        has_role(member, MANAGER_ROLE_ID),
        has_role(member, CEO_ROLE_ID),
        has_role(member, OWNER_ROLE_ID),
    ])

def get_logs_channel(guild: discord.Guild):
    return guild.get_channel(LOGS_CHANNEL_ID)

# ==========================
# EVENTS â€“ READY / AUTOROLE / WELCOME / LEAVE
# ==========================

@bot.event
async def on_ready():
    print(f"Logged in as {bot.user}")

@bot.event
async def on_member_join(member: discord.Member):
    role = member.guild.get_role(AUTOROLE_ID)
    if role:
        try:
            await member.add_roles(role)
        except:
            pass

    logs = get_logs_channel(member.guild)
    if logs:
        embed = discord.Embed(
            title="Member Joined",
            description=f"{member.mention} Î¼Ï€Î®ÎºÎµ ÏƒÏ„Î¿Î½ server.",
            color=discord.Color.green()
        )
        await logs.send(embed=embed)

@bot.event
async def on_member_remove(member: discord.Member):
    logs = get_logs_channel(member.guild)
    if logs:
        embed = discord.Embed(
            title="Member Left",
            description=f"{member} Î²Î³Î®ÎºÎµ Î±Ï€ÏŒ Ï„Î¿Î½ server.",
            color=discord.Color.red()
        )
        await logs.send(embed=embed)

# ==========================
# LOGS â€“ MESSAGE EDIT/DELETE
# ==========================

@bot.event
async def on_message_delete(message: discord.Message):
    if not message.guild or message.author.bot:
        return
    logs = get_logs_channel(message.guild)
    if logs:
        embed = discord.Embed(
            title="Message Deleted",
            color=discord.Color.red()
        )
        embed.add_field(name="User", value=f"{message.author}", inline=False)
        embed.add_field(name="Channel", value=message.channel.mention, inline=False)
        embed.add_field(name="Content", value=message.content or "No content", inline=False)
        await logs.send(embed=embed)

@bot.event
async def on_message_edit(before, after):
    if not after.guild or after.author.bot:
        return
    if before.content == after.content:
        return
    logs = get_logs_channel(after.guild)
    if logs:
        embed = discord.Embed(
            title="Message Edited",
            color=discord.Color.yellow()
        )
        embed.add_field(name="User", value=f"{after.author}", inline=False)
        embed.add_field(name="Before", value=before.content or "No content", inline=False)
        embed.add_field(name="After", value=after.content or "No content", inline=False)
        await logs.send(embed=embed)

# ==========================
# TEMPORARY SUPPORT VOICE (AUTO DELETE)
# ==========================

@bot.event
async def on_voice_state_update(member, before, after):
    logs = get_logs_channel(member.guild)

    # Logs Î³Î¹Î± join/leave/move
    if logs:
        if not before.channel and after.channel:
            await logs.send(embed=discord.Embed(
                title="Voice Join",
                description=f"{member.mention} Î¼Ï€Î®ÎºÎµ ÏƒÏ„Î¿ {after.channel.mention}",
                color=discord.Color.blue()
            ))
        elif before.channel and not after.channel:
            await logs.send(embed=discord.Embed(
                title="Voice Leave",
                description=f"{member.mention} Î²Î³Î®ÎºÎµ Î±Ï€ÏŒ {before.channel.mention}",
                color=discord.Color.red()
            ))
        elif before.channel and after.channel and before.channel.id != after.channel.id:
            await logs.send(embed=discord.Embed(
                title="Voice Move",
                description=f"{member.mention} Î¼ÎµÏ„Î±ÎºÎ¹Î½Î®Î¸Î·ÎºÎµ Î±Ï€ÏŒ {before.channel.mention} ÏƒÎµ {after.channel.mention}",
                color=discord.Color.yellow()
            ))

    # TEMP SUPPORT CALL
    try:
        # ÎœÏ€Î®ÎºÎµ ÏƒÏ„Î¿ main support VC â†’ Ï†Ï„Î¹Î¬Î¾Îµ Ï€ÏÎ¿ÏƒÏ‰ÏÎ¹Î½ÏŒ
        if after.channel and after.channel.id == SUPPORT_CALL_VC_ID:
            guild = member.guild
            category = guild.get_channel(TEMP_SUPPORT_CATEGORY_ID)

            overwrites = {
                guild.default_role: discord.PermissionOverwrite(view_channel=False, connect=False),
                member: discord.PermissionOverwrite(view_channel=True, connect=True),
                guild.get_role(STAFF_ROLE_ID): discord.PermissionOverwrite(view_channel=True, connect=True),
                guild.get_role(MANAGER_ROLE_ID): discord.PermissionOverwrite(view_channel=True, connect=True),
                guild.get_role(CEO_ROLE_ID): discord.PermissionOverwrite(view_channel=True, connect=True),
                guild.get_role(OWNER_ROLE_ID): discord.PermissionOverwrite(view_channel=True, connect=True),
            }

            temp_channel = await guild.create_voice_channel(
                name=f"support-{member.name}",
                category=category,
                overwrites=overwrites,
                reason="Temporary support call"
            )

            await member.move_to(temp_channel)

            async def delete_when_empty():
                while True:
                    ch = guild.get_channel(temp_channel.id)
                    if not ch or len(ch.members) == 0:
                        try:
                            await ch.delete(reason="Temp support call empty")
                        except:
                            pass
                        break
                    await asyncio.sleep(3)

            bot.loop.create_task(delete_when_empty())

    except Exception as e:
        print("Temp call error:", e)


# ==========================
# TICKET CLOSE BUTTON
# ==========================

class TicketCloseView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)

    @discord.ui.button(label="Close Ticket", style=discord.ButtonStyle.danger)
    async def close_ticket(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not is_staff_or_higher(interaction.user):
            return await interaction.response.send_message("Î”ÎµÎ½ Î­Ï‡ÎµÎ¹Ï‚ Î´Î¹ÎºÎ±Î¯Ï‰Î¼Î±.", ephemeral=True)

        await interaction.response.send_message("Î¤Î¿ ticket Î¸Î± ÎºÎ»ÎµÎ¯ÏƒÎµÎ¹ ÏƒÎµ 5 Î´ÎµÏ…Ï„ÎµÏÏŒÎ»ÎµÏ€Ï„Î±...", ephemeral=True)
        await asyncio.sleep(5)

        try:
            await interaction.channel.delete(reason="Ticket closed")
        except:
            pass

# ==========================
# TICKET CREATION FUNCTION (DYNAMIC NAMES)
# ==========================

async def create_ticket(interaction: discord.Interaction, ticket_type: str, category_id: int, allowed_roles: list[int]):
    guild = interaction.guild
    category = guild.get_channel(category_id)

    # ticket-type-username
    channel_name = f"{ticket_type}-{interaction.user.name}".replace(" ", "-").lower()

    overwrites = {
        guild.default_role: discord.PermissionOverwrite(view_channel=False),
        interaction.user: discord.PermissionOverwrite(view_channel=True, send_messages=True),
    }

    for role_id in allowed_roles:
        role = guild.get_role(role_id)
        if role:
            overwrites[role] = discord.PermissionOverwrite(view_channel=True, send_messages=True)

    channel = await guild.create_text_channel(
        name=channel_name,
        category=category,
        overwrites=overwrites,
        reason=f"{ticket_type} ticket opened"
    )

    embed = discord.Embed(
        title=f"{ticket_type.capitalize()} Ticket",
        description=f"Ticket Î±Ï€ÏŒ {interaction.user.mention}",
        color=discord.Color.blue()
    )
    await channel.send(content=interaction.user.mention, embed=embed, view=TicketCloseView())
    await interaction.response.send_message(f"Î¤Î¿ ticket ÏƒÎ¿Ï… Î¬Î½Î¿Î¹Î¾Îµ: {channel.mention}", ephemeral=True)

# ==========================
# STEP-BY-STEP APPLICATION SYSTEM
# ==========================

bot.active_applications = {}

class StepApplication:
    def __init__(self, user, questions, review_channel_id, title):
        self.user = user
        self.questions = questions
        self.answers = []
        self.current = 0
        self.review_channel_id = review_channel_id
        self.title = title
        self.channel = None

    async def start(self, guild):
        category = guild.get_channel(APPLICATION_CATEGORY_ID)

        overwrites = {
            guild.default_role: discord.PermissionOverwrite(view_channel=False),
            self.user: discord.PermissionOverwrite(view_channel=True, send_messages=True),
            guild.get_role(OWNER_ROLE_ID): discord.PermissionOverwrite(view_channel=True),
            guild.get_role(CEO_ROLE_ID): discord.PermissionOverwrite(view_channel=True),
        }

        self.channel = await guild.create_text_channel(
            name=f"application-{self.user.name}",
            category=category,
            overwrites=overwrites
        )

        await self.channel.send(
            embed=discord.Embed(
                title=f"{self.title} Application",
                description="Î— Î±Î¯Ï„Î·ÏƒÎ· Î¾ÎµÎºÎ¹Î½Î¬ Ï„ÏÏÎ±.",
                color=discord.Color.blue()
            )
        )

        await self.ask_next()

    async def ask_next(self):
        if self.current >= len(self.questions):
            await self.finish()
            return

        question = self.questions[self.current]
        await self.channel.send(
            embed=discord.Embed(
                title=f"Î•ÏÏÏ„Î·ÏƒÎ· {self.current + 1}",
                description=question,
                color=discord.Color.green()
            )
        )

    async def handle_answer(self, message):
        self.answers.append(message.content)
        self.current += 1
        await self.ask_next()

    async def finish(self):
        embed = discord.Embed(
            title=f"{self.title} Application Submitted",
            color=discord.Color.purple()
        )

        embed.add_field(name="User", value=f"{self.user} ({self.user.id})", inline=False)

        for i, (q, a) in enumerate(zip(self.questions, self.answers), start=1):
            embed.add_field(name=f"Q{i}: {q}", value=a, inline=False)

        review_channel = self.channel.guild.get_channel(self.review_channel_id)
        await review_channel.send(embed=embed, view=ApplicationDecisionView(self.user.id, self.title))

        await self.channel.send(
            embed=discord.Embed(
                title="Î— Î±Î¯Ï„Î·ÏƒÎ· Î¿Î»Î¿ÎºÎ»Î·ÏÏÎ¸Î·ÎºÎµ!",
                description="Î˜Î± ÎµÎ½Î·Î¼ÎµÏÏ‰Î¸ÎµÎ¯Ï‚ ÏƒÏÎ½Ï„Î¿Î¼Î±.",
                color=discord.Color.blue()
            )
        )


# ==========================
# APPLICATION DECISION BUTTONS
# ==========================

class ApplicationDecisionView(discord.ui.View):
    def __init__(self, user_id: int, title: str):
        super().__init__(timeout=None)
        self.user_id = user_id
        self.title = title

    @discord.ui.button(label="Accept with reason", style=discord.ButtonStyle.success)
    async def accept(self, interaction: discord.Interaction, button):
        if not is_owner_or_ceo(interaction.user):
            return await interaction.response.send_message("Î”ÎµÎ½ Î­Ï‡ÎµÎ¹Ï‚ Î´Î¹ÎºÎ±Î¯Ï‰Î¼Î±.", ephemeral=True)

        modal = AcceptModal(self.user_id, self.title)
        await interaction.response.send_modal(modal)

    @discord.ui.button(label="Denied with reason", style=discord.ButtonStyle.danger)
    async def deny(self, interaction: discord.Interaction, button):
        if not is_owner_or_ceo(interaction.user):
            return await interaction.response.send_message("Î”ÎµÎ½ Î­Ï‡ÎµÎ¹Ï‚ Î´Î¹ÎºÎ±Î¯Ï‰Î¼Î±.", ephemeral=True)

        modal = DenyModal(self.user_id, self.title)
        await interaction.response.send_modal(modal)


# ==========================
# ACCEPT / DENY MODALS
# ==========================

class AcceptModal(discord.ui.Modal, title="Accept Application"):
    reason = discord.ui.TextInput(label="Reason", style=discord.TextStyle.paragraph)

    def __init__(self, user_id: int, app_title: str):
        super().__init__()
        self.user_id = user_id
        self.app_title = app_title

    async def on_submit(self, interaction: discord.Interaction):
        user = await interaction.guild.fetch_member(self.user_id)

        await user.send(
            f"ğŸ‰ Î£Ï…Î³Ï‡Î±ÏÎ·Ï„Î®ÏÎ¹Î±! Î— Î±Î¯Ï„Î·ÏƒÎ® ÏƒÎ¿Ï… Î³Î¹Î± **{self.app_title}** Î­Î³Î¹Î½Îµ **Accept**.\nReason: {self.reason.value}"
        )

        await interaction.response.send_message("ÎˆÎ³Î¹Î½Îµ accept.", ephemeral=True)


class DenyModal(discord.ui.Modal, title="Deny Application"):
    reason = discord.ui.TextInput(label="Reason", style=discord.TextStyle.paragraph)

    def __init__(self, user_id: int, app_title: str):
        super().__init__()
        self.user_id = user_id
        self.app_title = app_title

    async def on_submit(self, interaction: discord.Interaction):
        user = await interaction.guild.fetch_member(self.user_id)

        await user.send(
            f"âŒ Î— Î±Î¯Ï„Î·ÏƒÎ® ÏƒÎ¿Ï… Î³Î¹Î± **{self.app_title}** Î­Î³Î¹Î½Îµ **Denied**.\nReason: {self.reason.value}"
        )

        await interaction.response.send_message("ÎˆÎ³Î¹Î½Îµ deny.", ephemeral=True)


# ==========================
# STAFF APPLICATION PANEL
# ==========================

class StaffApplicationPanel(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)

    @discord.ui.button(label="Apply for Staff", style=discord.ButtonStyle.primary)
    async def apply(self, interaction: discord.Interaction, button):
        questions = [
            "Î ÏŒÏƒÎ¿ Ï‡ÏÎ¿Î½ÏÎ½ ÎµÎ¯ÏƒÎ±Î¹;",
            "Î ÏŒÏƒÎµÏ‚ ÏÏÎµÏ‚ Î¼Ï€Î¿ÏÎµÎ¯Ï‚ Î½Î± ÎµÎ¯ÏƒÎ±Î¹ on duty;",
            "Î¤Î¹ ÎµÎ¯Î½Î±Î¹ Î· Î¹ÎµÏÎ±ÏÏ‡Î¯Î± Î³Î¹Î± ÏƒÎ­Î½Î±;",
            "ÎˆÏ‡ÎµÎ¹Ï‚ ÎµÎ¼Ï€ÎµÎ¹ÏÎ¯Î± Ï‰Ï‚ staff;",
            "Î ÎµÏ‚ 3 Î²Î±ÏƒÎ¹ÎºÎ¬ rules Ï„Î¿Ï… server.",
            "Î¤Î¹ ÎºÎ¬Î½ÎµÎ¹Ï‚ Î±Î½ Î´ÎµÎ½ Î¼Ï€Î¿ÏÎµÎ¯Ï‚ Î½Î± Î²Î¿Î·Î¸Î®ÏƒÎµÎ¹Ï‚ ÎºÎ¬Ï€Î¿Î¹Î¿Î½;",
            "Î Ï‰Ï‚ Î±Î½Ï„Î¹Î´ÏÎ¬Ï‚ ÏƒÎµ Î±Î½Ï„Î¹ÎµÏ€Î±Î³Î³ÎµÎ»Î¼Î±Ï„Î¹ÎºÎ® ÏƒÏ…Î¼Ï€ÎµÏÎ¹Ï†Î¿ÏÎ¬ staff;"
        ]

        app = StepApplication(
            user=interaction.user,
            questions=questions,
            review_channel_id=STAFF_APPS_REVIEW_CHANNEL_ID,
            title="Staff"
        )

        await app.start(interaction.guild)
        bot.active_applications[interaction.user.id] = app

        await interaction.response.send_message("Î— Î±Î¯Ï„Î·ÏƒÎ· Î¾ÎµÎºÎ¯Î½Î·ÏƒÎµ!", ephemeral=True)


# ==========================
# MANAGER APPLICATION PANEL
# ==========================

class ManagerApplicationPanel(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)

    @discord.ui.button(label="Apply for Manager", style=discord.ButtonStyle.danger)
    async def apply(self, interaction: discord.Interaction, button):
        questions = [
            "Î ÏŒÏƒÎ¿ Ï‡ÏÎ¿Î½ÏÎ½ ÎµÎ¯ÏƒÎ±Î¹;",
            "Î ÏŒÏƒÎµÏ‚ ÏÏÎµÏ‚ Î¼Ï€Î¿ÏÎµÎ¯Ï‚ Î½Î± ÎµÎ¯ÏƒÎ±Î¹ on duty;",
            "Î‘Î½Î­Ï†ÎµÏÎµ 3 Î²Î±ÏƒÎ¹ÎºÎ¬ rules.",
            "Î¤Î¹ ÎµÎ¯Î½Î±Î¹ Î· Î¹ÎµÏÎ±ÏÏ‡Î¯Î± Î³Î¹Î± ÏƒÎ­Î½Î±;",
            "ÎˆÏ‡ÎµÎ¹Ï‚ ÎµÎ¼Ï€ÎµÎ¹ÏÎ¯Î± ÏƒÏ„Î¿ management;",
            "Î Ï‰Ï‚ Î¸Î± Î±Î½Ï„Î¹Î¼ÎµÏ„ÏÏ€Î¹Î¶ÎµÏ‚ ÏƒÏÎ³ÎºÏÎ¿Ï…ÏƒÎ· ÏƒÏ„Î¿ team;",
            "Î¤Î¹ ÎºÎ¬Î½ÎµÎ¹Ï‚ Î±Î½ ÎºÎ¬Ï€Î¿Î¹Î¿Ï‚ Î´ÎµÎ½ Î±ÎºÎ¿ÏÎµÎ¹ ÎµÎ½Ï„Î¿Î»Î­Ï‚;",
            "Î¤Î¹ ÎºÎ¬Î½ÎµÎ¹Ï‚ Î±Î½ Î´ÎµÎ½ ÏƒÎ¿Ï… Î±ÏÎ­ÏƒÎµÎ¹ ÎµÎ½Ï„Î¿Î»Î® Î±Î½ÏÏ„ÎµÏÎ¿Ï…;"
        ]

        app = StepApplication(
            user=interaction.user,
            questions=questions,
            review_channel_id=MANAGER_APPS_REVIEW_CHANNEL_ID,
            title="Manager"
        )

        await app.start(interaction.guild)
        bot.active_applications[interaction.user.id] = app

        await interaction.response.send_message("Î— Î±Î¯Ï„Î·ÏƒÎ· Î¾ÎµÎºÎ¯Î½Î·ÏƒÎµ!", ephemeral=True)


# ==========================
# APPLICATION ANSWER LISTENER
# ==========================

@bot.event
async def on_message(message: discord.Message):
    if message.author.bot:
        return

    app = bot.active_applications.get(message.author.id)
    if app and message.channel == app.channel:
        await app.handle_answer(message)
        return

    await bot.process_commands(message)

# ==========================
# SUPPORT PANEL
# ==========================

class SupportTicketPanel(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)

    @discord.ui.button(label="OwnerğŸ‘‘", style=discord.ButtonStyle.red)
    async def owner_ticket(self, interaction: discord.Interaction, button):
        await create_ticket(
            interaction,
            ticket_type="owner",
            category_id=SUPPORT_TICKET_CATEGORY_ID,
            allowed_roles=[OWNER_ROLE_ID, CEO_ROLE_ID]
        )

    @discord.ui.button(label="SupportğŸ“", style=discord.ButtonStyle.red)
    async def support_ticket(self, interaction: discord.Interaction, button):
        await create_ticket(
            interaction,
            ticket_type="support",
            category_id=SUPPORT_TICKET_CATEGORY_ID,
            allowed_roles=[STAFF_ROLE_ID, MANAGER_ROLE_ID, CEO_ROLE_ID, OWNER_ROLE_ID]
        )

# ==========================
# BUY PANEL
# ==========================

class BuyTicketPanel(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)

    @discord.ui.button(label="OrderğŸ“¦", style=discord.ButtonStyle.green)
    async def me_ticket(self, interaction: discord.Interaction, button):
        await create_ticket(
            interaction,
            ticket_type="Order",
            category_id=BUY_TICKET_CATEGORY_ID,
            allowed_roles=[MANAGER_ROLE_ID, CEO_ROLE_ID, OWNER_ROLE_ID]
        )

    @discord.ui.button(label="BuyğŸ’¸", style=discord.ButtonStyle.green)
    async def order_ticket(self, interaction: discord.Interaction, button):
        await create_ticket(
            interaction,
            ticket_type="Buy",
            category_id=BUY_TICKET_CATEGORY_ID,
            allowed_roles=[MANAGER_ROLE_ID, CEO_ROLE_ID, OWNER_ROLE_ID]
        )

    @discord.ui.button(label="Claim RewardğŸ†", style=discord.ButtonStyle.green)
    async def reward_ticket(self, interaction: discord.Interaction, button):
        await create_ticket(
            interaction,
            ticket_type="reward",
            category_id=BUY_TICKET_CATEGORY_ID,
            allowed_roles=[MANAGER_ROLE_ID, CEO_ROLE_ID, OWNER_ROLE_ID]
        )

# ==========================
# SEND COMMAND (PANELS)
# ==========================

@bot.command()
async def send(ctx, panel_type=None, panel_name=None):
    if not is_staff_or_higher(ctx.author):
        return await ctx.reply("Î”ÎµÎ½ Î­Ï‡ÎµÎ¹Ï‚ Î´Î¹ÎºÎ±Î¯Ï‰Î¼Î±.")

    if panel_type is None or panel_name is None:
        return await ctx.reply(
            "Î§ÏÎ®ÏƒÎ·:\n"
            "`!send support panel`\n"
            "`!send buy panel`\n"
            "`!send staff panel`\n"
            "`!send manager panel`"
        )

    panel_type = panel_type.lower()
    panel_name = panel_name.lower()

    if panel_type == "support" and panel_name == "panel":
        embed = discord.Embed(
            title="Support Panel",
            description="Î•Ï€Î¯Î»ÎµÎ¾Îµ Ï„Î¹ ticket Î¸Î­Î»ÎµÎ¹Ï‚ Î½Î± Î±Î½Î¿Î¯Î¾ÎµÎ¹Ï‚.",
            color=discord.Color.blue()
        )
        return await ctx.send(embed=embed, view=SupportTicketPanel())

    if panel_type == "buy" and panel_name == "panel":
        embed = discord.Embed(
            title="Buy Panel",
            description="Î•Ï€Î¯Î»ÎµÎ¾Îµ Ï„Î¹ Î¸Î­Î»ÎµÎ¹Ï‚ Î½Î± ÎºÎ¬Î½ÎµÎ¹Ï‚.",
            color=discord.Color.green()
        )
        return await ctx.send(embed=embed, view=BuyTicketPanel())

    if panel_type == "staff" and panel_name == "panel":
        embed = discord.Embed(
            title="Staff Application Panel",
            description="Î Î±Ï„Î®ÏƒÏ„Îµ Î³Î¹Î± Î½Î± ÎºÎ¬Î½ÎµÏ„Îµ Î±Î¯Ï„Î·ÏƒÎ· Staff.",
            color=discord.Color.blue()
        )
        return await ctx.send(embed=embed, view=StaffApplicationPanel())

    if panel_type == "manager" and panel_name == "panel":
        embed = discord.Embed(
            title="Manager Application Panel",
            description="Î Î±Ï„Î®ÏƒÏ„Îµ Î³Î¹Î± Î½Î± ÎºÎ¬Î½ÎµÏ„Îµ Î±Î¯Ï„Î·ÏƒÎ· Manager.",
            color=discord.Color.red()
        )
        return await ctx.send(embed=embed, view=ManagerApplicationPanel())

    await ctx.reply("Î›Î¬Î¸Î¿Ï‚ Ï‡ÏÎ®ÏƒÎ· ÎµÎ½Ï„Î¿Î»Î®Ï‚.")

# ==========================
# MODERATION COMMANDS
# ==========================

@bot.command()
async def kick(ctx, member: discord.Member=None, *, reason=None):
    if not is_staff_or_higher(ctx.author):
        return await ctx.reply("Î”ÎµÎ½ Î­Ï‡ÎµÎ¹Ï‚ Î´Î¹ÎºÎ±Î¯Ï‰Î¼Î±.")
    if not member or not reason:
        return await ctx.reply("Î§ÏÎ®ÏƒÎ·: !kick @user reason")

    try:
        await member.kick(reason=reason)
        await ctx.reply(f"Kick: {member.mention} | Reason: {reason}")
    except:
        await ctx.reply("Î”ÎµÎ½ Î¼Ï€ÏŒÏÎµÏƒÎ± Î½Î± ÎºÎ¬Î½Ï‰ kick.")


@bot.command()
async def ban(ctx, member: discord.Member=None, *, reason=None):
    if not is_staff_or_higher(ctx.author):
        return await ctx.reply("Î”ÎµÎ½ Î­Ï‡ÎµÎ¹Ï‚ Î´Î¹ÎºÎ±Î¯Ï‰Î¼Î±.")
    if not member or not reason:
        return await ctx.reply("Î§ÏÎ®ÏƒÎ·: !ban @user reason")

    try:
        await member.ban(reason=reason)
        await ctx.reply(f"Ban: {member.mention} | Reason: {reason}")
    except:
        await ctx.reply("Î”ÎµÎ½ Î¼Ï€ÏŒÏÎµÏƒÎ± Î½Î± ÎºÎ¬Î½Ï‰ ban.")


@bot.command()
async def unban(ctx, user_id: int=None, *, reason=None):
    if not is_staff_or_higher(ctx.author):
        return await ctx.reply("Î”ÎµÎ½ Î­Ï‡ÎµÎ¹Ï‚ Î´Î¹ÎºÎ±Î¯Ï‰Î¼Î±.")
    if not user_id or not reason:
        return await ctx.reply("Î§ÏÎ®ÏƒÎ·: !unban user_id reason")

    try:
        user = await bot.fetch_user(user_id)
        await ctx.guild.unban(user, reason=reason)
        await ctx.reply(f"Unban: {user} | Reason: {reason}")
    except:
        await ctx.reply("Î”ÎµÎ½ Î¼Ï€ÏŒÏÎµÏƒÎ± Î½Î± ÎºÎ¬Î½Ï‰ unban.")


@bot.command()
async def timeout(ctx, member: discord.Member=None, minutes: int=None, *, reason=None):
    if not is_staff_or_higher(ctx.author):
        return await ctx.reply("Î”ÎµÎ½ Î­Ï‡ÎµÎ¹Ï‚ Î´Î¹ÎºÎ±Î¯Ï‰Î¼Î±.")
    if not member or not minutes or not reason:
        return await ctx.reply("Î§ÏÎ®ÏƒÎ·: !timeout @user minutes reason")

    try:
        until = discord.utils.utcnow() + discord.timedelta(minutes=minutes)
        await member.edit(timeout=until, reason=reason)
        await ctx.reply(f"Timeout: {member.mention} Î³Î¹Î± {minutes} Î»ÎµÏ€Ï„Î¬ | Reason: {reason}")
    except:
        await ctx.reply("Î”ÎµÎ½ Î¼Ï€ÏŒÏÎµÏƒÎ± Î½Î± ÎºÎ¬Î½Ï‰ timeout.")


# ==========================
# BOT PANEL
# ==========================

@bot.command()
async def botpanel(ctx):
    embed = discord.Embed(
        title="Bot Panel",
        color=discord.Color.purple()
    )
    embed.add_field(name="Tickets", value="!send support panel, !send buy panel", inline=False)
    embed.add_field(name="Applications", value="!send staff panel, !send manager panel", inline=False)
    embed.add_field(name="Moderation", value="!kick, !ban, !unban, !timeout", inline=False)
    await ctx.send(embed=embed)


# ==========================
# RUN BOT
# ==========================

keep_alive()
bot.run("")






